#!/usr/bin/python

# Copyright (c) 2013 The ANGLE Project Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import json

# This file contains the definitions for all the builtin in JSON format.
json_data = open('builtin_symbols.json')
builtin = json.load(json_data)

# This maps the shader language's types and how to create the TTypes in the symbol table.
ttypeMap = builtin["ttypemap"]

# This is the output that we are going to generate.
output = open('builtin_symbol_table.cpp', 'w');

# The header part of the file.
header = """// Copyright (c) 2002-2013 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// *************************************************************
// This file is generated by generate_builtin_symbol_table.py.
//                 * DO NOT HAND MODIFY *
// *************************************************************
#include "compiler/builtin_symbol_table.h"
#include "compiler/SymbolTable.h"
"""
output.write(header)

registerfunc = """
static void builtin1(TSymbolTable* t, TType* rvalue, const char* name, TType* ptype1, const char* pname1)
{
  TFunction* f = new TFunction(new TString(name), *rvalue);
  TParameter param = {new TString(pname1), ptype1};
  f->addParameter(param);
  t->insert(*f);
}

static void builtin2(TSymbolTable* t, TType* rvalue, const char* name, TType* ptype1, const char* pname1, TType* ptype2, const char* pname2)
{
  TFunction* f = new TFunction(new TString(name), *rvalue);
  TParameter param1 = {new TString(pname1), ptype1};
  f->addParameter(param1);
  TParameter param2 = {new TString(pname2), ptype2};
  f->addParameter(param2);
  t->insert(*f);
}

static void builtin3(TSymbolTable* t, TType* rvalue, const char* name, TType* ptype1, const char* pname1, TType* ptype2, const char* pname2, TType* ptype3, const char* pname3)
{
  TFunction* f = new TFunction(new TString(name), *rvalue);
  TParameter param1 = {new TString(pname1), ptype1};
  f->addParameter(param1);
  TParameter param2 = {new TString(pname2), ptype2};
  f->addParameter(param2);
  TParameter param3 = {new TString(pname3), ptype3};
  f->addParameter(param3);
  t->insert(*f);
}

"""
output.write(registerfunc)

# A function that parses the JSON representation of a list of builtin functions.
def parseBuiltin(name):
    for func in builtin[name]:
        out = ""
        indent = "    ";
        size = len(func['parameter'])
        if 'condition' in func:
            out += indent + "if (" + func['condition'] + ") {\n"
            indent += indent;
        out += indent + "builtin" + str(size) + "(t, "
        out += ttypeMap[func['return_type']]
        out += ", \"" + func['name'] + "\""
        paramlist = func['parameter']
        paramdef = "";
        for param in paramlist:
            paramdef += ", "
            paramdef += ttypeMap[param['type']] 
            paramdef += ", \"" + param['name'] + "\""
        out += paramdef + ");\n"
        if 'condition' in func:
            out += "    }\n"
        output.write(out)

commonHeader = "void InsertBuiltInFunctionsCommon(const ShBuiltInResources& resources, TSymbolTable* t) {\n"
output.write(commonHeader)
parseBuiltin("common")
output.write("}\n\n")

vertexHeader = "void InsertBuiltInFunctionsVertex(const ShBuiltInResources& resources, TSymbolTable* t) {\n"
output.write(vertexHeader)
parseBuiltin("vertex")
output.write("}\n\n")

json_data.close()
output.close()
